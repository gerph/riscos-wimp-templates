/*******************************************************************
 * File:        templates
 * Purpose:     Template manipulation
 * Author:      Gerph
 * Date:        2 Nov 2025
 ******************************************************************/

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "ctrlstring.h"
#include "templates.h"
#include "bufferdata.h"
#include "types.h"

#define DEBUG

#ifdef DEBUG
#define dprintf if (1) printf
#else
#define dprintf if (0) printf
#endif


static opentemplate_t *opentemplates;


/*************************************************** Gerph *********
 Function:      templates_read_word
 Description:   Read a 32bit value from the open template file
 Parameters:    ot-> the template we are reading
 Returns:       the word we read
 ******************************************************************/
uint32_t templates_read_word(opentemplate_t *ot)
{
    uint32_t word;
    int read = fread(&word, 1, sizeof(word), ot->fh);
    if (read != sizeof(word))
        return READ_EOF;
    return word;
}

/*************************************************** Gerph *********
 Function:      templates_read
 Description:   Read an arbitrary size of data from the open template file
 Parameters:    ot-> the template we are reading
 Returns:       the amount of data we read
 ******************************************************************/
uint32_t templates_read(opentemplate_t *ot, void *dest, int size)
{
    int read = fread(dest, 1, size, ot->fh);
    return read;
}

/*************************************************** Gerph *********
 Function:      templates_seek
 Description:   Seek to a place within the file, using the SEEK_* types
 Parameters:    ot-> the template we are reading
                offset = where to seek
                how = how to seek: SEEK_SET = absolute
                                   SEEK_CUR = relative to current
                                   SEEK_END = relative to end
 Returns:       error code
 ******************************************************************/
int templates_seek(opentemplate_t *ot, fileoffset_t offset, int how)
{
    return fseek(ot->fh, offset, how);
}


/*************************************************** Gerph *********
 Function:      templates_open
 Description:   Open a template file (backend for Wimp_OpenTemplate)
 Parameters:    filename-> filename to open
 Returns:       pointer to a open template object, or NULL if we failed
 ******************************************************************/
opentemplate_t *templates_open(const char *filename)
{
    opentemplate_t *ot;
    FILE *fh;

    ot = malloc(sizeof(*ot));
    if (ot == NULL)
        return NULL;

    fh = fopen(filename, "rb");
    if (fh == NULL)
    {
        dprintf("templates_open: Failed to open file '%s'\n", filename);
        free(ot);
        return NULL;
    }

    dprintf("templates_open: Opened template file '%s'\n", filename);
    ot->fh = fh;

    /* First word should be font data offset, then 3 words of 0s */
    ot->font_data_offset = templates_read_word(ot);
    if (ot->font_data_offset == 0xFFFFFFFFlu)
        ot->font_data_offset = 0;
    dprintf("Font data offset = &%05x\n", ot->font_data_offset);

    if (templates_read_word(ot) != 0 ||
        templates_read_word(ot) != 0 ||
        templates_read_word(ot) != 0)
    {
        goto failed;
    }

    {
        /* Count the number of entries in the header */
        int nentries = 0;
        int size;
        templateindexentry_t *entries;
        while (1)
        {
            uint32_t data_offset = templates_read_word(ot);
            if (data_offset == 0)
                break;
            templates_seek(ot, sizeof(templateindexentry_t) - 4, SEEK_CUR);
            nentries++;
        }

        /* We've now counted the entries; so we can read the lot into out workspace */
        size = sizeof(templateindexentry_t) * nentries;
        entries = malloc(size);
        if (entries == NULL)
            goto failed;

        templates_seek(ot, 16, SEEK_SET);
        ot->entries = entries;
        ot->nentries = nentries;
        if (templates_read(ot, entries, size) != size)
        {
            dprintf("Could not read all the template data; give up\n");
            goto failed;
        }

        /* Validate all the entries */
        {
            int i;
            for (i =0; i < ot->nentries; i++)
            {
                int len = ctrlstrlen(ot->entries[i].identifier);
                if (len > 11)
                {
                    dprintf("Invalid length of the identifier in template %i\n", i);
                    goto failed;
                }
                /* FIXME: identifiers should be allowed to be 12 character long, unterminated */

                ot->entries[i].identifier[len] = '\0';
                /* FIXME: Check the offset and length are in the file */
                /* FIXME: Should we check that the template names aren't repeated? */
            }
        }

#ifdef DEBUG
        {
            int i;
            dprintf("templates_open: Read header...\n");
            for (i =0; i < ot->nentries; i++)
            {
                dprintf("%3i : offset &%05x, size &%04x, type %u, identifier %s\n",
                        i,
                        ot->entries[i].data_offset,
                        ot->entries[i].data_size,
                        ot->entries[i].data_type,
                        ot->entries[i].identifier);
            }
        }
#endif
    }

    /* Linked to our tracked chain */
    ot->next = opentemplates;
    opentemplates = ot;

    return ot;

failed:
    fclose(ot->fh);
    free(ot);
    /* FIXME: Better way of reporting errors ? */
    return NULL;
}

/*************************************************** Gerph *********
 Function:      templates_close
 Description:   Close an open template file
 Parameters:    ot-> the template to close
 Returns:       0 for success, 1 for failure
 ******************************************************************/
int templates_close(opentemplate_t *ot)
{
    /* Unlink from the chain */
    opentemplate_t **lastp = &opentemplates;
    opentemplate_t *cur = opentemplates;
    while (cur)
    {
        if (cur==ot)
        {
            *lastp = cur->next; /* unlink from the chain */

            dprintf("Closing open template file\n");
            fclose(ot->fh);
            free(ot->entries);
            free(ot);
            return 0;
        }

        lastp = &ot->next;
        ot = ot->next;
    }
    dprintf("File handle is not open - cannot close\n");
    return 1;
}


/*************************************************** Gerph *********
 Function:      templates_findidentifier
 Description:   Find a template block by its string identifier
 Parameters:    ot-> the template file we are operating on
                ctrl-> identifier we are finding (ctrl-terminated)
 Returns:       index to the template to use, or -1 if invalid
 ******************************************************************/
int templates_findidentifier(opentemplate_t *ot, ctrlstring_t ctrl)
{
    int i;
    for (i=0; i<ot->nentries; i++)
    {
        templateindexentry_t *ientry = &ot->entries[i];
        if (ctrlstrcmp(ientry->identifier, ctrl) == 0)
        {
            return i;
        }
    }
    return -1;
}

typedef struct loadtemplatedata_s {
    opentemplate_t *ot;
    bufferdata_t *bufwin;
    bufferdata_t *bufind;
    int base_offset;
} loadtemplatedata_t;


/*************************************************** Gerph *********
 Function:      templates_stringindirect
 Description:   Copy a string from the templates file to the indirect buffer, with length
 Parameters:    ltd-> load template data structure
                ind_offset = indirect data offset from window base offset
                length = the size in the indirect buffer
                textp-> where to store the indirect buffer text (or NULL if not written)
 Returns:       template error code
 ******************************************************************/
templateerror_t templates_stringindirect(loadtemplatedata_t *ltd,
                                         int ind_offset,
                                         int length,
                                         uint8_t **textp)
{
    int wrote = 0;
    uint8_t *text = bufferdata_address(ltd->bufind, 0, true);
    *textp = NULL;

    templates_seek(ltd->ot, ltd->base_offset + ind_offset, SEEK_SET);
    dprintf("Reading indirect string from offset &%x to address %p\n", ltd->base_offset + ind_offset, text);
    while (1)
    {
        int c = fgetc(ltd->ot->fh);
        if (c==EOF)
            return TE_EOF;

        if (c < 32)
            c = 0;
        if (length == -1 || length - 1 <= wrote)
        {
            if (length != -1 && length - 1 == wrote)
            {
                /* last byte, so we terminate */
                int zero = 0;
                bufferdata_write_bytes(ltd->bufind, &zero, 1);
            }
            else
            {
                bufferdata_write_bytes(ltd->bufind, &c, 1);
            }
            wrote += 1;
        }
        if (c == 0)
            break;
    }
    if (length != -1 && wrote != length)
    {
        /* Write padding to the end of the indirected data field */
        printf("Padding by %i bytes\n", length - wrote);
        bufferdata_write_bytespadded(ltd->bufind, NULL, 0, length - wrote);
    }

    if (!bufferdata_failed(ltd->bufind))
        *textp = text;

    return TE_OK;
}


/*************************************************** Gerph *********
 Function:      templates_writeicondata
 Description:   Write an icondata into the user's buffer
 Parameters:    ot-> the template we are operating on
                bufwin-> the buffer to write the window into
                bufind-> the buffer to write indirected data into
                icondata-> the icon's data
 Returns:       template error code
 ******************************************************************/
static templateerror_t templates_writeicondata(loadtemplatedata_t *ltd,
                                               Wimp_IconFlags iconflags,
                                               Wimp_IconData *icondata)
{
    templateerror_t terr;

    dprintf("Processing icon, flags &%08x\n", iconflags);

    if ( (iconflags & (Wimp_IconText | Wimp_IconSprite)) &&
         (iconflags & Wimp_IconIndirected) )
    {
        // Fixup if the icon contains text/sprite and is indirected.
        int text_offset = icondata->indirected_text.text;
        int validation_offset = icondata->indirected_text.validation;
        int32_t length = icondata->indirected_text.size;
        uint8_t *text = NULL;
        uint8_t *validation = NULL;

        if ( (iconflags & (Wimp_IconText | Wimp_IconSprite)) == Wimp_IconSprite )
        {
            // It's an indirected sprite, so it might have a sprite name, or might be
            // a sprite pointer. It's almost always going to be a sprite name, but we
            // check nonetheless.
            if (length == 0)
                // It's a sprite pointer; flag as an invalid text_offset
                text_offset = 0;
        }

        if (text_offset != 0)
        {
            terr = templates_stringindirect(ltd, text_offset, length, &text);
            if (terr != TE_OK)
                return terr;
        }

        if (iconflags & Wimp_IconText)
        {
            if (validation_offset != 0)
            {
                terr = templates_stringindirect(ltd, validation_offset, -1, &validation);
                if (terr != TE_OK)
                    return terr;
            }
        }

        dprintf("  Indirect Text(%i): %s\n", length, text ? (char*)text : "<not written>");
        dprintf("  Validation: %s\n", validation ? (char*)validation : "<not written>");

    }

/*
    if iconflags & (Wimp_IconText | Wimp_IconSprite) and \
       iconflags & Wimp_IconIndirected:

        (text_offset, validation_offset, length) = struct.unpack('<LLL', icondata)

        text = None
        validation = None
        if iconflags & (Wimp_IconText | Wimp_IconSprite) == \
                Wimp_IconSprite:
            # It's an indirected sprite, so it might have a sprite name, or might be
            # a sprite pointer. It's almost always going to be a sprite name, but we
            # check nonetheless.
            if length == 0:
                # It's a sprite pointer; flag as an invalid text_offset
                text_offset = 0

        if text_offset != 0:
            self.seek(params['template_fileptr'] + text_offset)
            text = self.read_string()

        if iconflags & Wimp_IconText:
            if validation_offset != 0:
                self.seek(params['template_fileptr'] + validation_offset)
                validation = self.read_string()
        if self.debug_wimptemplate:
            print("  Indirect Text(%i): %r" % (length, text))
            print("  Validation: %r" % (validation,))

        # Put the text into the workspace
        if text is not None:
            space_needed = length + 1
            if params['workspace_size_used'] + space_needed <= params['workspace_size']:
                # We can fit the data in the buffer.
                workspace[params['workspace_size_used']] = text
                text_offset = workspace.address + params['workspace_size_used']
            else:
                if self.debug_wimptemplate:
                    print("  - does not fit in the workspace block")
                # FIXME: If it does not fit, should we error?
            params['workspace_size_used'] += space_needed

        # Put the validation into the workspace
        if validation is not None:
            space_needed = len(validation) + 1
            if params['workspace_size_used'] + space_needed <= params['workspace_size']:
                # We can fit the data in the buffer.
                workspace[params['workspace_size_used']] = validation
                validation_offset = workspace.address + params['workspace_size_used']
            else:
                if self.debug_wimptemplate:
                    print("  - does not fit in the workspace block")
                # FIXME: If it does not fit, should we error?
            params['workspace_size_used'] += space_needed

        # FIXME: We don't support fonts here?

        # Rebuild the icon data
        if self.debug_wimptemplate:
            print("  Rebuilt as: &%08x, &%08x, %i" % (text_offset, validation_offset, length))
        icondata = struct.pack("<LLL", text_offset, validation_offset, length)

    elif iconflags & Wimp_IconText:
        # For debugging
        if self.debug_wimptemplate:
            text = re.sub('[\x00-\x1f].*$', '', icondata, flags=re.DOTALL)
            print("  Text: %r" % (text,))
*/

    bufferdata_write_bytes(ltd->bufwin, icondata, sizeof(*icondata));

    return TE_OK;
}

/*************************************************** Gerph *********
 Function:      templates_readtemplate
 Description:   Read a template into a user buffer
 Parameters:    ot-> the template file we are operating on
                index = the index of the template we're reading
                bufwin-> the buffer to write the window into
                bufind-> the buffer to write indirected data into
 Returns:       template error code
 ******************************************************************/
templateerror_t templates_readtemplate(opentemplate_t *ot, int index,
                                       bufferdata_t *bufwin,
                                       bufferdata_t *bufind)
{
    int size = ot->entries[index].data_size;
    int offset = ot->entries[index].data_offset;
    Wimp_Window win;
    int read;
    int iconnum;
    loadtemplatedata_t ltd;
    templates_seek(ot, offset, SEEK_SET);

    read = templates_read(ot, &win, Wimp_WindowHeaderSize);
    if (read != Wimp_WindowHeaderSize)
        return TE_EOF;

    bufferdata_write_bytes(bufwin, &win.visible, sizeof(win.visible));
    bufferdata_write_bytes(bufwin, &win.xscroll, sizeof(win.xscroll) + sizeof(win.yscroll));
    bufferdata_write_word(bufwin, 0xFFFFFFFF); /* Always force window to top */
    bufferdata_write_word(bufwin, win.flags);
    bufferdata_write_bytes(bufwin, &win.title_fg, sizeof(win.title_fg) * 7 + sizeof(win.extra_flags)); /* The colours */
    bufferdata_write_bytes(bufwin, &win.extent, sizeof(win.extent));
    bufferdata_write_bytes(bufwin, &win.title_flags, sizeof(win.title_flags) * 2); /* Title + work area flags */
    bufferdata_write_word(bufwin, 1); /* FIXME: Should I be forcing sprite area to be the Wimp sprite pool? */
    bufferdata_write_bytes(bufwin, &win.xmin, sizeof(win.xmin) * 2);

    ltd.ot = ot;
    ltd.bufwin = bufwin;
    ltd.bufind = bufind;
    ltd.base_offset = offset;
    dprintf("Writing window data from template offset &%x, %i icons\n", offset, win.icon_count);
    dprintf("window base offset = &%x\n",ltd.base_offset);
    /* FIXME: The font data will need passing in too */

    /* Fixup title data */
    templates_writeicondata(&ltd, win.title_flags, &win.title_data);

    bufferdata_write_word(bufwin, win.icon_count);
    for (iconnum=0; iconnum < win.icon_count; iconnum++)
    {
        Wimp_Icon *icon = &win.icons[0];
        templates_seek(ot, offset, SEEK_SET);
        read = templates_read(ot, icon, sizeof(Wimp_Icon));
        if (read != sizeof(Wimp_Icon))
            return TE_EOF;
        offset += read;

        bufferdata_write_bytes(bufwin, &icon->extent, sizeof(icon->extent));
        bufferdata_write_word(bufwin, icon->flags);

        /* Handle the icon data */
        templates_writeicondata(&ltd, icon->flags, &icon->data);
    }

    return TE_OK;
}




