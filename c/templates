/*******************************************************************
 * File:        templates
 * Purpose:     Template manipulation
 * Author:      Gerph
 * Date:        2 Nov 2025
 ******************************************************************/

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "ctrlstring.h"
#include "templates.h"
#include "bufferdata.h"
#include "types.h"

#define DEBUG

#ifdef DEBUG
#define dprintf if (1) printf
#else
#define dprintf if (0) printf
#endif


static opentemplate_t *opentemplates;


/*************************************************** Gerph *********
 Function:      templates_read_word
 Description:   Read a 32bit value from the open template file
 Parameters:    ot-> the template we are reading
 Returns:       the word we read
 ******************************************************************/
uint32_t templates_read_word(opentemplate_t *ot)
{
    uint32_t word;
    int read = fread(&word, 1, sizeof(word), ot->fh);
    if (read != sizeof(word))
        return READ_EOF;
    return word;
}

/*************************************************** Gerph *********
 Function:      templates_read
 Description:   Read an arbitrary size of data from the open template file
 Parameters:    ot-> the template we are reading
 Returns:       the amount of data we read
 ******************************************************************/
uint32_t templates_read(opentemplate_t *ot, void *dest, int size)
{
    int read = fread(dest, 1, size, ot->fh);
    return read;
}

/*************************************************** Gerph *********
 Function:      templates_seek
 Description:   Seek to a place within the file, using the SEEK_* types
 Parameters:    ot-> the template we are reading
                offset = where to seek
                how = how to seek: SEEK_SET = absolute
                                   SEEK_CUR = relative to current
                                   SEEK_END = relative to end
 Returns:       error code
 ******************************************************************/
int templates_seek(opentemplate_t *ot, fileoffset_t offset, int how)
{
    return fseek(ot->fh, offset, how);
}


/*************************************************** Gerph *********
 Function:      templates_open
 Description:   Open a template file (backend for Wimp_OpenTemplate)
 Parameters:    filename-> filename to open
 Returns:       pointer to a open template object, or NULL if we failed
 ******************************************************************/
opentemplate_t *templates_open(const char *filename)
{
    opentemplate_t *ot;
    FILE *fh;

    ot = malloc(sizeof(*ot));
    if (ot == NULL)
        return NULL;

    fh = fopen(filename, "rb");
    if (fh == NULL)
    {
        dprintf("templates_open: Failed to open file '%s'\n", filename);
        free(ot);
        return NULL;
    }

    dprintf("templates_open: Opened template file '%s'\n", filename);
    ot->fh = fh;

    /* First word should be font data offset, then 3 words of 0s */
    ot->font_data_offset = templates_read_word(ot);
    if (ot->font_data_offset == 0xFFFFFFFFlu)
        ot->font_data_offset = 0;
    dprintf("Font data offset = &%05x\n", ot->font_data_offset);

    if (templates_read_word(ot) != 0 ||
        templates_read_word(ot) != 0 ||
        templates_read_word(ot) != 0)
    {
        goto failed;
    }

    {
        /* Count the number of entries in the header */
        int nentries = 0;
        int size;
        templateindexentry_t *entries;
        while (1)
        {
            uint32_t data_offset = templates_read_word(ot);
            if (data_offset == 0)
                break;
            templates_seek(ot, sizeof(templateindexentry_t) - 4, SEEK_CUR);
            nentries++;
        }

        /* We've now counted the entries; so we can read the lot into out workspace */
        size = sizeof(templateindexentry_t) * nentries;
        entries = malloc(size);
        if (entries == NULL)
            goto failed;

        templates_seek(ot, 16, SEEK_SET);
        ot->entries = entries;
        ot->nentries = nentries;
        if (templates_read(ot, entries, size) != size)
        {
            dprintf("Could not read all the template data; give up\n");
            goto failed;
        }

        /* Validate all the entries */
        {
            int i;
            for (i =0; i < ot->nentries; i++)
            {
                int len = ctrlstrlen(ot->entries[i].identifier);
                if (len > 11)
                {
                    dprintf("Invalid length of the identifier in template %i\n", i);
                    goto failed;
                }
                /* FIXME: identifiers should be allowed to be 12 character long, unterminated */

                ot->entries[i].identifier[len] = '\0';
                /* FIXME: Check the offset and length are in the file */
                /* FIXME: Should we check that the template names aren't repeated? */
            }
        }

#ifdef DEBUG
        {
            int i;
            dprintf("templates_open: Read header...\n");
            for (i =0; i < ot->nentries; i++)
            {
                dprintf("%3i : offset &%05x, size &%04x, type %u, identifier %s\n",
                        i,
                        ot->entries[i].data_offset,
                        ot->entries[i].data_size,
                        ot->entries[i].data_type,
                        ot->entries[i].identifier);
            }
        }
#endif
    }

    /* Linked to our tracked chain */
    ot->next = opentemplates;
    opentemplates = ot;

    return ot;

failed:
    fclose(ot->fh);
    free(ot);
    /* FIXME: Better way of reporting errors ? */
    return NULL;
}

/*************************************************** Gerph *********
 Function:      templates_close
 Description:   Close an open template file
 Parameters:    ot-> the template to close
 Returns:       0 for success, 1 for failure
 ******************************************************************/
int templates_close(opentemplate_t *ot)
{
    /* Unlink from the chain */
    opentemplate_t **lastp = &opentemplates;
    opentemplate_t *cur = opentemplates;
    while (cur)
    {
        if (cur==ot)
        {
            *lastp = cur->next; /* unlink from the chain */

            dprintf("Closing open template file\n");
            fclose(ot->fh);
            free(ot->entries);
            free(ot);
            return 0;
        }

        lastp = &ot->next;
        ot = ot->next;
    }
    dprintf("File handle is not open - cannot close\n");
    return 1;
}


/*************************************************** Gerph *********
 Function:      templates_findidentifier
 Description:   Find a template block by its string identifier
 Parameters:    ot-> the template file we are operating on
                ctrl-> identifier we are finding (ctrl-terminated)
 Returns:       index to the template to use, or -1 if invalid
 ******************************************************************/
int templates_findidentifier(opentemplate_t *ot, ctrlstring_t ctrl)
{
    int i;
    for (i=0; i<ot->nentries; i++)
    {
        templateindexentry_t *ientry = &ot->entries[i];
        if (ctrlstrcmp(ientry->identifier, ctrl) == 0)
        {
            return i;
        }
    }
    return -1;
}


/*************************************************** Gerph *********
 Function:      templates_writeicondata
 Description:   Write an icondata into the user's buffer
 Parameters:    ot-> the template we are operating on
                bufwin-> the buffer to write the window into
                bufind-> the buffer to write indirected data into
                icondata-> the icon's data
 Returns:       template error code
 ******************************************************************/
static templateerror_t templates_writeicondata(opentemplate_t *ot,
                                               bufferdata_t *bufwin,
                                               bufferdata_t *bufind,
                                               Wimp_IconFlags iconflags,
                                               Wimp_IconData *icondata)
{
    /* FIXME: Implement properly */
    bufferdata_write_bytes(bufwin, icondata, sizeof(*icondata));

    return TE_OK;
}

/*************************************************** Gerph *********
 Function:      templates_readtemplate
 Description:   Read a template into a user buffer
 Parameters:    ot-> the template file we are operating on
                index = the index of the template we're reading
                bufwin-> the buffer to write the window into
                bufind-> the buffer to write indirected data into
 Returns:       template error code
 ******************************************************************/
templateerror_t templates_readtemplate(opentemplate_t *ot, int index,
                                       bufferdata_t *bufwin,
                                       bufferdata_t *bufind)
{
    int size = ot->entries[index].data_size;
    int offset = ot->entries[index].data_offset;
    Wimp_Window win;
    int read;
    int iconnum;
    templates_seek(ot, offset, SEEK_SET);

    read = templates_read(ot, &win, Wimp_WindowHeaderSize);
    if (read != Wimp_WindowHeaderSize)
        return TE_EOF;
    offset += offset;

    bufferdata_write_bytes(bufwin, &win.visible, sizeof(win.visible));
    bufferdata_write_bytes(bufwin, &win.xscroll, sizeof(win.xscroll) + sizeof(win.yscroll));
    bufferdata_write_word(bufwin, 0xFFFFFFFF); /* Always force window to top */
    bufferdata_write_word(bufwin, win.flags);
    bufferdata_write_bytes(bufwin, &win.title_fg, sizeof(win.title_fg) * 7 + sizeof(win.extra_flags)); /* The colours */
    bufferdata_write_bytes(bufwin, &win.extent, sizeof(win.extent));
    bufferdata_write_bytes(bufwin, &win.title_flags, sizeof(win.title_flags) * 2); /* Title + work area flags */
    bufferdata_write_word(bufwin, 1); /* FIXME: Should I be forcing sprite area to be the Wimp sprite pool? */
    bufferdata_write_bytes(bufwin, &win.xmin, sizeof(win.xmin) * 2);

    /* FIXME: Title data */
    //Wimp_IconData title_data;
    templates_writeicondata(ot, bufwin, bufind, win.title_flags, &win.title_data);

    bufferdata_write_word(bufwin, win.icon_count);
    for (iconnum=0; iconnum < win.icon_count; iconnum++)
    {
        Wimp_Icon *icon = &win.icons[0];
        templates_seek(ot, offset, SEEK_SET);
        read = templates_read(ot, icon, sizeof(Wimp_Icon));
        if (read != sizeof(Wimp_Icon))
            return TE_EOF;
        offset += read;

        bufferdata_write_bytes(bufwin, &icon->extent, sizeof(icon->extent));
        bufferdata_write_word(bufwin, icon->flags);

        /* Handle the icon data */
        templates_writeicondata(ot, bufwin, bufind, icon->flags, &icon->data);
    }

    return TE_OK;
}




